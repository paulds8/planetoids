<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>planetoids API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#planetoids.Planetoid">Planetoid</a></span>
        
          
  <ul>
    <li class="mono"><a href="#planetoids.Planetoid.__init__">__init__</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.add_empty_trace">add_empty_trace</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.fit">fit</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.fit_terraform">fit_terraform</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.generate_highlight_polygons">generate_highlight_polygons</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.generate_hillshade_polygons">generate_hillshade_polygons</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.generate_relief">generate_relief</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.get_all_contours">get_all_contours</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.plot_clustered_points">plot_clustered_points</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.plot_contours">plot_contours</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.plot_highlight">plot_highlight</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.plot_relief">plot_relief</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.plot_shadows">plot_shadows</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.plot_surface">plot_surface</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.save">save</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.terraform">terraform</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.update_geos">update_geos</a></li>
    <li class="mono"><a href="#planetoids.Planetoid.update_layout">update_layout</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">planetoids</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids', this);">Show source &equiv;</a></p>
  <div id="source-planetoids" class="source">
    <pre><code>import numpy as np
import pandas as pd
import umap
import pyproj  # pip install pyproj==2.2.1 --no-cache-dir
import plotly.graph_objects as go
from plotly import offline
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import scipy.stats as st
import cv2 as cv
from tqdm.autonotebook import tqdm
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from PIL import Image
from shapely.geometry import asPoint
from shapely.geometry import asLineString
from shapely.geometry import asPolygon
from shapely.ops import unary_union
import random

# from shapely.geometry import MultiPoint
# from shapely.ops import transform
# from functools import partial
from functools import reduce
from plotly.subplots import make_subplots


class Planetoid(object):
    def __init__(
        self,
        data,
        y,
        x,
        cluster_field=None,
        ecology="gist_earth",
        random_state=None
    ):

        self.data = None
        self.y = None
        self.x = None
        self.cluster_field = None
        self.ecology = None
        self.random_state=None
        
        self.data_generated = False

        if isinstance(data, pd.DataFrame):
            self.data = data
        else:
            raise ValueError("Please provide a pandas DataFrame")
        if y in self.data.columns:
            self.y = y
        else:
            raise ValueError("X field not in provided DataFrame")
        if x in self.data.columns:
            self.x = x
        else:
            raise ValueError("Y field not in provided DataFrame")
        if cluster_field is not None or cluster_field in self.data.columns:
            self.cluster_field = cluster_field
        else:
            raise ValueError("Cluster field not in provided DataFrame")
        try:
            cm.get_cmap(ecology, 1)
            self.ecology = ecology
        except Exception as e:
            raise ValueError(e)
        if isinstance(random_state, int):
            self.random_state = random_state
            np.random.seed(self.random_state)
            random.seed(self.random_state)
            cv.setRNGSeed(self.random_state)
        elif random_state is None:
            pass
        else:
            raise ValueError("Please provide an integer value for your random seed")
            

        # only keep what we need
        self.data = self.data[[y, x, cluster_field]]

        # set the rest
        self.contours = dict()
        self.ocean_colour = None
        self.fig = None
        self.cmap = None
        self.max_contour = None
        self.shadows = list()
        self.highlight = list()
        self.topos = list()
        self.relief = list()

    def _rescale_coordinates(self):
        """Rescale provided components as pseudo latitudes and longitudes."""
        # trying to prevent issues at the extremes
        lat_scaler = MinMaxScaler(feature_range=(-80, 80))
        long_scaler = MinMaxScaler(feature_range=(-170, 170))

        self.data["Latitude"] = lat_scaler.fit_transform(
            self.data[self.y].values.reshape(-1, 1)
        ).reshape(-1)
        self.data["Longitude"] = long_scaler.fit_transform(
            self.data[self.x].values.reshape(-1, 1)
        ).reshape(-1)

        # self.data.plot(kind='scatter',
        #                 x='Longitude',
        #                 y='Latitude',
        #                 c=self.cluster_field,
        #                 cmap='Spectral')
        # plt.show()

    def _get_contours(self, cluster, subset, topography_levels, lighting_levels, relief_density):
        """Generate contour lines based on density of points per
        cluster/class."""

        # this is required since we need to throw some of them away later
        topography_levels += 5

        y = subset["Latitude"].values
        x = subset["Longitude"].values

        # Define the borders
        deltaX = (max(x) - min(x)) / 3
        deltaY = (max(y) - min(y)) / 3
        xmin = max(-180, min(x) - deltaX)
        xmax = min(180, max(x) + deltaX)
        ymin = max(-90, min(y) - deltaY)
        ymax = min(90, max(y) + deltaY)
        # print(xmin, xmax, ymin, ymax)
        # Create meshgrid
        # todo: let a user specify the grid density
        xx, yy = np.mgrid[
            xmin : xmax : (30 * 10 + 1j),#(30 * topography_levels + 1j),
            ymin : ymax : (30 * 10 + 1j),#(30 * topography_levels + 1j),
        ]

        positions = np.vstack([xx.ravel(), yy.ravel()])
        values = np.vstack([x, y])
        kernel = st.gaussian_kde(values)
        # an attempt at adding slightly more detail to the relief
        kernel.set_bandwidth(bw_method=kernel.factor / 1.2)
        f = np.reshape(kernel(positions).T, xx.shape)
        self.topos.append(f)

        hillshade = self._calculate_hillshade(np.rot90(f), 315, 45)

        fig = plt.figure(figsize=(8, 8))
        ax = fig.gca()
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(ymin, ymax)
        # cfset = ax.contourf(xx, yy, f, cmap='coolwarm')
        # ax.imshow(np.rot90(f), cmap='coolwarm', extent=[-180, 180, -90, 90])
        cset = ax.contour(xx, yy, f, colors="k", levels=topography_levels)
        plt.close(fig)

        cntrs = self._clean_contours(self._get_contour_verts(cset))

        self.contours[cluster] = cntrs

        self.generate_hillshade_polygons(
            hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
        )
        self.generate_highlight_polygons(
            hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
        )
        self.relief.append(self.generate_relief(f, xx, yy, cntrs, relief_density))

        return cntrs
    
    def _get_contour_verts(self, cn):
        """Get the vertices from the mpl plot to generate our own
        geometries."""
        cntr = []
        # for each contour line
        for cc in cn.collections:
            paths = []
            # for each separate section of the contour line
            for pp in cc.get_paths():
                xy = []
                # for each segment of that section
                for vv in pp.iter_segments():
                    xy.append(vv[0])
                paths.append(np.vstack(xy))

            cntr.append(paths)

        return cntr

    def generate_hillshade_polygons(
        self, hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
    ):

        # self.shadows = list()

        # we have to strech it for the opencv function to catch the edges properly
        hs_array = (
            (hillshade - hillshade.min()) / (hillshade.max() - hillshade.min()) * 255
        )
        hist, bin_edges = np.histogram(hs_array, bins=lighting_levels + 5)
        # bin_centers = 0.5*(bin_edges[:-1] + bin_edges[1:])

        # still need to refine this, but this piece here should help catch only the shadows and not the 'light side'
        bin_edges = [x for x in bin_edges if x > 180]

        cluster_shadows = []
        for b in list(zip(bin_edges[:-1], bin_edges[1:])):
            hs_array_binary_slice = hs_array.copy()
            hs_array_binary_slice[
                (hs_array_binary_slice < b[0]) & (hs_array_binary_slice != 1)
            ] = 0
            hs_array_binary_slice[
                (hs_array_binary_slice >= b[0]) & (hs_array_binary_slice < b[1])
            ] = 1
            # hs_array_binary_slice[(hs_array_binary_slice>=b[1]) & (hs_array_binary_slice != 1)] = 0

            hs_array_binary_slice = np.flipud(hs_array_binary_slice)
            hs_array_binary_slice = hs_array_binary_slice.astype(np.uint8)

            # plt.imshow(hs_array_binary_slice,cmap='Greys', extent=[xmin, xmax, ymin, ymax])
            # plt.show()

            contours, hierarchy = cv.findContours(
                hs_array_binary_slice.copy(), cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE
            )
            for cntr in contours:
                x_loc = [xx[pair[0][0], pair[0][1]] for pair in cntr]
                y_loc = [yy[pair[0][0], pair[0][1]] for pair in cntr]

                # get rid of polygons that touch the bondary of the calculated extent
                if (
                    xmin not in x_loc
                    and xmax not in x_loc
                    and ymin not in y_loc
                    and ymax not in y_loc
                ):
                    coords = list(zip(x_loc + [x_loc[0]], y_loc + [y_loc[0]]))
                    if len(coords) > 3:
                        # attempt some smoothing and reorienting of generated polygons
                        coords = list(
                            asPolygon(coords)
                            .simplify(0.01)
                            .buffer(3, join_style=1)
                            .buffer(-3, join_style=1)
                            .exterior.coords
                        )
                        cluster_shadows.append(coords)
        self.shadows.append(cluster_shadows)

    def generate_highlight_polygons(
        self, hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
    ):

        # self.shadows = list()

        # we have to strech it for the opencv function to catch the edges properly
        hs_array = (
            (hillshade - hillshade.min()) / (hillshade.max() - hillshade.min()) * 255
        )
        hist, bin_edges = np.histogram(hs_array, bins=lighting_levels + 5)
        # bin_centers = 0.5*(bin_edges[:-1] + bin_edges[1:])

        # still need to refine this, but this piece here should help catch only the 'light side' highlights
        bin_edges = [x for x in bin_edges if x <= 70]

        highlight = []
        for b in list(zip(bin_edges[:-1], bin_edges[1:])):
            hs_array_binary_slice = hs_array.copy()
            hs_array_binary_slice[
                (hs_array_binary_slice < b[0]) & (hs_array_binary_slice != 1)
            ] = 0
            hs_array_binary_slice[
                (hs_array_binary_slice >= b[0]) & (hs_array_binary_slice < b[1])
            ] = 1
            # hs_array_binary_slice[(hs_array_binary_slice>=b[1]) & (hs_array_binary_slice != 1)] = 0

            hs_array_binary_slice = np.flipud(hs_array_binary_slice)
            hs_array_binary_slice = hs_array_binary_slice.astype(np.uint8)

            # plt.imshow(hs_array_binary_slice,cmap='Greys', extent=[xmin, xmax, ymin, ymax])
            # plt.show()

            contours, hierarchy = cv.findContours(
                hs_array_binary_slice.copy(), cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE
            )
            for cntr in contours:
                x_loc = [xx[pair[0][0], pair[0][1]] for pair in cntr]
                y_loc = [yy[pair[0][0], pair[0][1]] for pair in cntr]

                # get rid of polygons that touch the bondary of the calculated extent
                if (
                    xmin not in x_loc
                    and xmax not in x_loc
                    and ymin not in y_loc
                    and ymax not in y_loc
                ):
                    coords = list(zip(x_loc + [x_loc[0]], y_loc + [y_loc[0]]))
                    if len(coords) > 3:
                        # attempt some smoothing
                        coords = list(
                            asPolygon(coords)
                            .simplify(0.01)
                            .buffer(3, join_style=1)
                            .buffer(-3, join_style=1)
                            .exterior.coords
                        )
                        highlight.append(coords)
        self.highlight.append(highlight)

        # #plot
        # fig = plt.figure(figsize=(8,8))
        # ax = fig.gca()
        # ax.set_xlim(xmin, xmax)
        # ax.set_ylim(ymin, ymax)
        # plt.imshow(hs_array,cmap='Greys', extent=[xmin, xmax, ymin, ymax])
        # plt.show()

    def get_all_contours(self, topography_levels=20, lighting_levels=20, relief_density=3):
        """Get all of the contours per class."""
        for cluster in tqdm(
            np.unique(self.data["Cluster"].values), desc="Generating data"
        ):
            points_df = self.data.loc[
                self.data["Cluster"] == cluster, ["Longitude", "Latitude"]
            ]
            self._get_contours(cluster, points_df, topography_levels, lighting_levels, relief_density)

    def generate_relief(
        self, f, xx, yy, cntrs, density=3, min_length=0.005, max_length=0.2
    ):
        """Still need to have a proper rationale for this apart from it
        potentially looking good.

        since this effectively represents the gradient of the topography - is it good enough to use
        this as a proxy for either global winds and eventually repurpose for ocean currents now?
        Need to think about this carefully.
        Need to find a way to put a legitimate 'spin' on the primary axis of the planetoid and model this out
        for the currents
        """

        # create a matplotlib figure and adjust the width and heights
        fig = plt.figure()

        # create a single subplot, just takes over the whole figure if only one is specified
        ax = fig.add_subplot(111, frameon=False, xticks=[], yticks=[])

        # create the boundary
        aoe = unary_union(
            [
                asPolygon(x)
                for x in [item for sublist in cntrs for item in sublist]
                if len(x) > 0
            ]
        ).buffer(-3)

        # add a streamplot
        dy, dx = np.gradient(f)
        c = np.sqrt(dx * dx + dy * dy)
        stream_container = plt.streamplot(
            yy,
            xx,
            dx,
            dy,
            color="c",
            density=density,
            linewidth=1.0 * c / c.max(),
            arrowsize=0.1,
            minlength=min_length,
            maxlength=max_length,
        )

        # this is the data we're extracting from the relief
        widths = np.round(stream_container.lines.get_linewidth(), 1)
        segments = stream_container.lines.get_segments()

        segments_with_width = [
            [segments[i], widths[i]] for i in range(0, len(segments))
        ]

        cleaned = [
            [asLineString(p[0][:, [1, 0]]), p[1]]
            for p in segments_with_width
            if -90 < p[0][0].any() < 90 and -180 < p[0][1].any() < 180
        ]
        stream_container = [p for p in cleaned if p[0].intersects(aoe)]

        plt.close(fig)

        return stream_container

    def _clean_contours(self, cntrs):
        """Use Shapely to modify the contours to prevent the case where Plotly
        fills the inverted section instead."""
        cleaned = list()
        for ix, line in enumerate(cntrs):
            for il, l in enumerate(line):
                # expanding and contracting like this has a smoothing effect
                poly = (
                    asPolygon(l).buffer(0.01, join_style=1).buffer(-0.01, join_style=1)
                )
                if poly.geom_type == "MultiPolygon":
                    polys = [np.array(p.exterior.coords) for p in list(poly)]
                    coords = []
                    for co in coords:
                        if co.shape[0] >= 3:
                            coords.append(co)
                    cleaned.append(coords)

                else:
                    coords = np.array(poly.exterior.coords)
                    if coords.shape[0] >= 3:
                        cleaned.append([coords])
        return cleaned

    def _calculate_hillshade(self, array, azimuth, angle_altitude):
        """Calculate a hillshade over the generated topography."""

        # hacky fix for now - need to trace what's making the mirroring necessary
        azimuth += 180
        if azimuth >= 360:
            azimuth = azimuth - 360

        x, y = np.gradient(array)
        slope = np.pi / 2.0 - np.arctan(np.sqrt(x * x + y * y))
        aspect = np.arctan2(-x, y)
        azimuthrad = azimuth * np.pi / 180.0
        altituderad = angle_altitude * np.pi / 180.0
        shaded = np.sin(altituderad) * np.sin(slope) + np.cos(altituderad) * np.cos(
            slope
        ) * np.cos(azimuthrad - aspect)
        return 255 * (shaded + 1) / 2

    def plot_surface(self):
        """This plots the surface layer which we need because we can't set it
        directly."""
        # globe
        self.fig.add_trace(
            go.Scattergeo(
                lon=[-179.9, 179.9, 179.9, -179.9],
                lat=[89.9, 89.9, -89.9, -89.9],
                mode="lines",
                line=dict(width=1, color=self.ocean_colour),
                fill="toself",
                fillcolor=self.ocean_colour,
                hoverinfo="skip",
                opacity=1,
                showlegend=False,
            ),
            row=2,
            col=1,
        )

    def plot_shadows(self):
        """Plot the hillshade-derived shadows."""
        # globe
        for cluster in tqdm(self.shadows, desc="Plotting Shadows"):
            for ix, shadow in enumerate(cluster):
                if ix % 2 == 0:
                    shadow_array = np.array(shadow)
                    self.fig.add_trace(
                        go.Scattergeo(
                            lon=list(shadow_array[:, 0]),
                            lat=list(shadow_array[:, 1]),
                            hoverinfo="skip",
                            mode="lines",
                            line=dict(width=0, color="black"),
                            fill="toself",
                            fillcolor="black",
                            opacity=0.05 + (ix/len(cluster)*0.1),
                            showlegend=False,
                        ),
                        row=2,
                        col=1,
                    )

    def plot_highlight(self):
        """Plot the hillshade-derived lighting."""
        # globe
        for cluster in tqdm(self.highlight, desc="Plotting highlight"):
            for ix, lighting in enumerate(cluster):
                if ix % 2 == 0:
                    lighting_array = np.array(lighting)
                    self.fig.add_trace(
                        go.Scattergeo(
                            lon=list(lighting_array[:, 0]),
                            lat=list(lighting_array[:, 1]),
                            hoverinfo="skip",
                            mode="lines",
                            line=dict(width=0, color="white"),
                            fill="toself",
                            fillcolor="white",
                            opacity=0.01 + (ix/len(cluster)*0.1),
                            showlegend=False,
                        ),
                        row=2,
                        col=1,
                    )

    def plot_contours(self):
        """Plot the topography."""
        for cluster, cntrs in tqdm(self.contours.items(), desc="Plotting contours"):
            #introduce some randomness in the topography layering
            contours = cntrs.copy()
            dont_shuffle_start = contours[0:5]
            dont_shuffle_end = contours[-2:]
            do_shuffle = contours[5:-2]
            random.shuffle(do_shuffle)
            contours = dont_shuffle_start + do_shuffle + dont_shuffle_end
            
            for ix, line in enumerate(contours):
                if ix > (self.max_contour - 3) / len(contours) + 2:
                    if ix % 2 == 0:
                        for l in line:
                            self.fig.add_trace(
                                go.Scattergeo(
                                    lon=list(l[:, 0]),
                                    lat=list(l[:, 1]),
                                    hoverinfo="skip",
                                    mode="lines",
                                    line=dict(
                                        width=0,  # *np.power(np.exp(ix/max_contour),2),
                                        dash="longdashdot",
                                        color="rgb"
                                        + str(
                                            self.cmap(
                                                ix / self.max_contour, bytes=True
                                            )[0:3]
                                        ),
                                    ),
                                    fill="toself",
                                    fillcolor="rgb"
                                    + str(
                                        self.cmap(ix / self.max_contour, bytes=True)[
                                            0:3
                                        ]
                                    ),
                                    opacity=0.05 + ((ix / self.max_contour) * 0.3),
                                    showlegend=False,
                                ),
                                row=2,
                                col=1,
                            )
                    else:
                        for l in line:
                            self.fig.add_trace(
                                go.Scattergeo(
                                    lon=list(l[:, 0]),
                                    lat=list(l[:, 1]),
                                    hoverinfo="skip",
                                    mode="lines",
                                    line=dict(
                                        width=1,  # *np.power(np.exp(ix/max_contour),2),
                                        dash="longdashdot",
                                        color="rgb"
                                        + str(
                                            self.cmap(
                                                ix / self.max_contour, bytes=True
                                            )[0:3]
                                        ),
                                    ),
                                    opacity=0.1 + ((ix / self.max_contour) * 0.5),
                                    showlegend=False,
                                ),
                                row=2,
                                col=1,
                            )

    def plot_relief(self):
        """Plot the relief."""
        # globe
        for cluster in tqdm(self.relief, desc="Plotting relief"):

            for size in np.unique([x[1] for x in cluster]):

                # need to be smarter about segments that touch

                stream_array = np.array(
                    [stream[0].coords for stream in cluster if stream[1] == size]
                )
                stream_array = np.concatenate(
                    [
                        item
                        for sublist in [
                            [x, np.array([[None, None], [None, None]])]
                            for x in stream_array
                        ]
                        for item in sublist
                    ]
                )

                self.fig.add_trace(
                    go.Scattergeo(
                        connectgaps=False,
                        lon=list(stream_array[:, 0]),
                        lat=list(stream_array[:, 1]),
                        hoverinfo="skip",
                        mode="lines",
                        line=dict(
                            width=2 * size,
                            # dash='dot',
                            color='black'#"rgb"
                            #+ str(
                            #    self.cmap(int(stream_array.shape[0] / 3), bytes=True)[0:3]
                            #),
                        ),
                        opacity=0.1 + 0.15 * (1 / np.cos(size) - 1),
                        showlegend=False,
                    ),
                    row=2,
                    col=1,
                )

    def plot_clustered_points(self):
        """Plot the provided point data."""

        # globe
        self.fig.add_trace(
            go.Scattergeo(
                lon=self.data["Longitude"],
                lat=self.data["Latitude"],
                marker_color=self.data["Cluster"],
                hoverinfo="text",
                hovertext=self.data["Cluster"],
                marker_size=2,
                showlegend=False
                #     marker = dict(
                #         symbol='circle-open',
                #      )
            ),
            row=2,
            col=1,
        )

    def update_geos(self):
        """Update config for maps."""
        # globe
        self.fig.update_geos(
            row=2,
            col=1,
            showland=False,
            showcountries=False,
            showocean=False,
            showcoastlines=False,
            showframe=False,
            showrivers=False,
            showlakes=False,
            showsubunits=False,
            bgcolor="rgba(0,0,0,0)",
            projection=dict(type=self.projection, rotation=dict(lon=0, lat=0, roll=0)),
            lonaxis=dict(showgrid=True, gridcolor="rgb(102, 102, 102)", gridwidth=1),
            lataxis=dict(showgrid=True, gridcolor="rgb(102, 102, 102)", gridwidth=1),
        )

    def add_empty_trace(self):
        """Add invisible scatter trace.

        This trace is added to help the autoresize logic work.
        """

        width = int(1920 / 2)
        height = int(1280 / 2)
        self.fig.add_trace(
            go.Scatter(
                x=[0, width],
                y=[0, height],
                mode="markers",
                marker_opacity=0,
                showlegend=False,
            )
        )

        # Configure axes
        self.fig.update_xaxes(visible=False, fixedrange=True, range=[0, width])

        self.fig.update_yaxes(
            visible=False,
            fixedrange=True,
            range=[0, height],
            # the scaleanchor attribute ensures that the aspect ratio stays constant
            scaleanchor="x",
        )

    def update_layout(self, planet_name="Planetoids"):
        """Update layout config."""

        width = int(1920 / 2)
        height = int(1280 / 2)

        image_array = np.zeros((width, height))
        image_array = self._add_salt_and_pepper(image_array, 0.001).astype("uint8")
        image = Image.fromarray(image_array)

        self.fig.update_layout(
            autosize=True,
            width=width,
            height=height,
            title_text=planet_name,
            showlegend=True,
            dragmode="pan",
            plot_bgcolor="rgba(0,0,0,0)",
            paper_bgcolor="rgba(0,0,0,0)",
            margin=dict(l=2, r=2, t=0, b=0),
            images=[
                dict(
                    source=image,
                    xref="x",
                    yref="y",
                    x=0,
                    y=height,
                    sizex=width,
                    sizey=height,
                    sizing="stretch",
                    opacity=1,
                    layer="below",
                )
            ],
        )
        
    def fit(self, topography_levels=20, lighting_levels=20, relief_density=3):
        """Generate data required for terraforming."""
        # transform 2d components into pseudo lat/longs
        self._rescale_coordinates()
        # generate contours per class
        self.get_all_contours(topography_levels, lighting_levels, relief_density)
        self.data_generated = True

    def terraform(
        self,
        plot_topography=True,
        plot_points=True,
        plot_lighting=True,
        projection = 'orthographic',
        planet_name="Planetoids",
        render=True,
    ):
        """Construct a new world."""
        
        self.projection = projection
        
        if not self.data_generated:
            raise Exception("Please first run .fit() before attemption to terraform.")
        else:
            self.fig = make_subplots(
                rows=3,
                cols=2,
                vertical_spacing=0.05,
                # column_widths=[0.5, 0.5],
                row_heights=[0.05, 0.93, 0.02],
                specs=[
                    [None, None],
                    [{"type": "scattergeo", "colspan": 2}, None],
                    [None, None],
                ],
                subplot_titles=(planet_name, ""),
            )

            self.add_empty_trace()

            # identify the maximum number of contours per continent
            self.max_contour = max([len(contour) for contour in self.contours.values()])
            self.cmap = cm.get_cmap(self.ecology, self.max_contour + 1)

            self.ocean_colour = "rgb" + str(
                self.cmap(1 / self.max_contour, bytes=True)[0:3]
            )

            self.plot_surface()

            if plot_topography:
                self.plot_contours()

            self.plot_relief()

            if plot_lighting:
                self.plot_highlight()
                self.plot_shadows()

            if plot_points:
                self.plot_clustered_points()

            self.update_geos()

            self.update_layout(planet_name)

            if render:
                self.fig.show()

    def fit_terraform(
        self,
        topography_levels=20,
        lighting_levels=20,
        relief_density=3,
        plot_topography=True,
        plot_points=True,
        plot_lighting=True,
        projection='orthographic',
        planet_name="Planetoids",
        render=True,
    ):
        """Fit and terraform in a single step, akin to fit_transform people are
        used to."""
        self.fit(topography_levels=topography_levels, lighting_levels=lighting_levels, relief_density=relief_density)
        self.terraform(plot_topography, plot_points, plot_lighting, projection, planet_name, render)

    def save(self, filename="planetoid.html", output_type='file', include_plotlyjs=True, auto_open=False):
        offline.plot(self.fig, filename = filename, output_type=output_type, include_plotlyjs=include_plotlyjs, auto_open=auto_open)


    def _add_salt_and_pepper(self, gb, prob):
        """Adds "Salt & Pepper" noise to an image.

        gb: should be one-channel image with pixels in [0, 1] range
        prob: probability (threshold) that controls level of noise
        """

        rnd = np.random.rand(gb.shape[0], gb.shape[1])
        noisy = gb.copy()
        noisy[rnd < prob] = 0
        noisy[rnd > 1 - prob] = 255
        return noisy
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="planetoids.Planetoid" class="name">class <span class="ident">Planetoid</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid" class="source">
    <pre><code>class Planetoid(object):
    def __init__(
        self,
        data,
        y,
        x,
        cluster_field=None,
        ecology="gist_earth",
        random_state=None
    ):

        self.data = None
        self.y = None
        self.x = None
        self.cluster_field = None
        self.ecology = None
        self.random_state=None
        
        self.data_generated = False

        if isinstance(data, pd.DataFrame):
            self.data = data
        else:
            raise ValueError("Please provide a pandas DataFrame")
        if y in self.data.columns:
            self.y = y
        else:
            raise ValueError("X field not in provided DataFrame")
        if x in self.data.columns:
            self.x = x
        else:
            raise ValueError("Y field not in provided DataFrame")
        if cluster_field is not None or cluster_field in self.data.columns:
            self.cluster_field = cluster_field
        else:
            raise ValueError("Cluster field not in provided DataFrame")
        try:
            cm.get_cmap(ecology, 1)
            self.ecology = ecology
        except Exception as e:
            raise ValueError(e)
        if isinstance(random_state, int):
            self.random_state = random_state
            np.random.seed(self.random_state)
            random.seed(self.random_state)
            cv.setRNGSeed(self.random_state)
        elif random_state is None:
            pass
        else:
            raise ValueError("Please provide an integer value for your random seed")
            

        # only keep what we need
        self.data = self.data[[y, x, cluster_field]]

        # set the rest
        self.contours = dict()
        self.ocean_colour = None
        self.fig = None
        self.cmap = None
        self.max_contour = None
        self.shadows = list()
        self.highlight = list()
        self.topos = list()
        self.relief = list()

    def _rescale_coordinates(self):
        """Rescale provided components as pseudo latitudes and longitudes."""
        # trying to prevent issues at the extremes
        lat_scaler = MinMaxScaler(feature_range=(-80, 80))
        long_scaler = MinMaxScaler(feature_range=(-170, 170))

        self.data["Latitude"] = lat_scaler.fit_transform(
            self.data[self.y].values.reshape(-1, 1)
        ).reshape(-1)
        self.data["Longitude"] = long_scaler.fit_transform(
            self.data[self.x].values.reshape(-1, 1)
        ).reshape(-1)

        # self.data.plot(kind='scatter',
        #                 x='Longitude',
        #                 y='Latitude',
        #                 c=self.cluster_field,
        #                 cmap='Spectral')
        # plt.show()

    def _get_contours(self, cluster, subset, topography_levels, lighting_levels, relief_density):
        """Generate contour lines based on density of points per
        cluster/class."""

        # this is required since we need to throw some of them away later
        topography_levels += 5

        y = subset["Latitude"].values
        x = subset["Longitude"].values

        # Define the borders
        deltaX = (max(x) - min(x)) / 3
        deltaY = (max(y) - min(y)) / 3
        xmin = max(-180, min(x) - deltaX)
        xmax = min(180, max(x) + deltaX)
        ymin = max(-90, min(y) - deltaY)
        ymax = min(90, max(y) + deltaY)
        # print(xmin, xmax, ymin, ymax)
        # Create meshgrid
        # todo: let a user specify the grid density
        xx, yy = np.mgrid[
            xmin : xmax : (30 * 10 + 1j),#(30 * topography_levels + 1j),
            ymin : ymax : (30 * 10 + 1j),#(30 * topography_levels + 1j),
        ]

        positions = np.vstack([xx.ravel(), yy.ravel()])
        values = np.vstack([x, y])
        kernel = st.gaussian_kde(values)
        # an attempt at adding slightly more detail to the relief
        kernel.set_bandwidth(bw_method=kernel.factor / 1.2)
        f = np.reshape(kernel(positions).T, xx.shape)
        self.topos.append(f)

        hillshade = self._calculate_hillshade(np.rot90(f), 315, 45)

        fig = plt.figure(figsize=(8, 8))
        ax = fig.gca()
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(ymin, ymax)
        # cfset = ax.contourf(xx, yy, f, cmap='coolwarm')
        # ax.imshow(np.rot90(f), cmap='coolwarm', extent=[-180, 180, -90, 90])
        cset = ax.contour(xx, yy, f, colors="k", levels=topography_levels)
        plt.close(fig)

        cntrs = self._clean_contours(self._get_contour_verts(cset))

        self.contours[cluster] = cntrs

        self.generate_hillshade_polygons(
            hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
        )
        self.generate_highlight_polygons(
            hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
        )
        self.relief.append(self.generate_relief(f, xx, yy, cntrs, relief_density))

        return cntrs
    
    def _get_contour_verts(self, cn):
        """Get the vertices from the mpl plot to generate our own
        geometries."""
        cntr = []
        # for each contour line
        for cc in cn.collections:
            paths = []
            # for each separate section of the contour line
            for pp in cc.get_paths():
                xy = []
                # for each segment of that section
                for vv in pp.iter_segments():
                    xy.append(vv[0])
                paths.append(np.vstack(xy))

            cntr.append(paths)

        return cntr

    def generate_hillshade_polygons(
        self, hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
    ):

        # self.shadows = list()

        # we have to strech it for the opencv function to catch the edges properly
        hs_array = (
            (hillshade - hillshade.min()) / (hillshade.max() - hillshade.min()) * 255
        )
        hist, bin_edges = np.histogram(hs_array, bins=lighting_levels + 5)
        # bin_centers = 0.5*(bin_edges[:-1] + bin_edges[1:])

        # still need to refine this, but this piece here should help catch only the shadows and not the 'light side'
        bin_edges = [x for x in bin_edges if x > 180]

        cluster_shadows = []
        for b in list(zip(bin_edges[:-1], bin_edges[1:])):
            hs_array_binary_slice = hs_array.copy()
            hs_array_binary_slice[
                (hs_array_binary_slice < b[0]) & (hs_array_binary_slice != 1)
            ] = 0
            hs_array_binary_slice[
                (hs_array_binary_slice >= b[0]) & (hs_array_binary_slice < b[1])
            ] = 1
            # hs_array_binary_slice[(hs_array_binary_slice>=b[1]) & (hs_array_binary_slice != 1)] = 0

            hs_array_binary_slice = np.flipud(hs_array_binary_slice)
            hs_array_binary_slice = hs_array_binary_slice.astype(np.uint8)

            # plt.imshow(hs_array_binary_slice,cmap='Greys', extent=[xmin, xmax, ymin, ymax])
            # plt.show()

            contours, hierarchy = cv.findContours(
                hs_array_binary_slice.copy(), cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE
            )
            for cntr in contours:
                x_loc = [xx[pair[0][0], pair[0][1]] for pair in cntr]
                y_loc = [yy[pair[0][0], pair[0][1]] for pair in cntr]

                # get rid of polygons that touch the bondary of the calculated extent
                if (
                    xmin not in x_loc
                    and xmax not in x_loc
                    and ymin not in y_loc
                    and ymax not in y_loc
                ):
                    coords = list(zip(x_loc + [x_loc[0]], y_loc + [y_loc[0]]))
                    if len(coords) > 3:
                        # attempt some smoothing and reorienting of generated polygons
                        coords = list(
                            asPolygon(coords)
                            .simplify(0.01)
                            .buffer(3, join_style=1)
                            .buffer(-3, join_style=1)
                            .exterior.coords
                        )
                        cluster_shadows.append(coords)
        self.shadows.append(cluster_shadows)

    def generate_highlight_polygons(
        self, hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
    ):

        # self.shadows = list()

        # we have to strech it for the opencv function to catch the edges properly
        hs_array = (
            (hillshade - hillshade.min()) / (hillshade.max() - hillshade.min()) * 255
        )
        hist, bin_edges = np.histogram(hs_array, bins=lighting_levels + 5)
        # bin_centers = 0.5*(bin_edges[:-1] + bin_edges[1:])

        # still need to refine this, but this piece here should help catch only the 'light side' highlights
        bin_edges = [x for x in bin_edges if x <= 70]

        highlight = []
        for b in list(zip(bin_edges[:-1], bin_edges[1:])):
            hs_array_binary_slice = hs_array.copy()
            hs_array_binary_slice[
                (hs_array_binary_slice < b[0]) & (hs_array_binary_slice != 1)
            ] = 0
            hs_array_binary_slice[
                (hs_array_binary_slice >= b[0]) & (hs_array_binary_slice < b[1])
            ] = 1
            # hs_array_binary_slice[(hs_array_binary_slice>=b[1]) & (hs_array_binary_slice != 1)] = 0

            hs_array_binary_slice = np.flipud(hs_array_binary_slice)
            hs_array_binary_slice = hs_array_binary_slice.astype(np.uint8)

            # plt.imshow(hs_array_binary_slice,cmap='Greys', extent=[xmin, xmax, ymin, ymax])
            # plt.show()

            contours, hierarchy = cv.findContours(
                hs_array_binary_slice.copy(), cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE
            )
            for cntr in contours:
                x_loc = [xx[pair[0][0], pair[0][1]] for pair in cntr]
                y_loc = [yy[pair[0][0], pair[0][1]] for pair in cntr]

                # get rid of polygons that touch the bondary of the calculated extent
                if (
                    xmin not in x_loc
                    and xmax not in x_loc
                    and ymin not in y_loc
                    and ymax not in y_loc
                ):
                    coords = list(zip(x_loc + [x_loc[0]], y_loc + [y_loc[0]]))
                    if len(coords) > 3:
                        # attempt some smoothing
                        coords = list(
                            asPolygon(coords)
                            .simplify(0.01)
                            .buffer(3, join_style=1)
                            .buffer(-3, join_style=1)
                            .exterior.coords
                        )
                        highlight.append(coords)
        self.highlight.append(highlight)

        # #plot
        # fig = plt.figure(figsize=(8,8))
        # ax = fig.gca()
        # ax.set_xlim(xmin, xmax)
        # ax.set_ylim(ymin, ymax)
        # plt.imshow(hs_array,cmap='Greys', extent=[xmin, xmax, ymin, ymax])
        # plt.show()

    def get_all_contours(self, topography_levels=20, lighting_levels=20, relief_density=3):
        """Get all of the contours per class."""
        for cluster in tqdm(
            np.unique(self.data["Cluster"].values), desc="Generating data"
        ):
            points_df = self.data.loc[
                self.data["Cluster"] == cluster, ["Longitude", "Latitude"]
            ]
            self._get_contours(cluster, points_df, topography_levels, lighting_levels, relief_density)

    def generate_relief(
        self, f, xx, yy, cntrs, density=3, min_length=0.005, max_length=0.2
    ):
        """Still need to have a proper rationale for this apart from it
        potentially looking good.

        since this effectively represents the gradient of the topography - is it good enough to use
        this as a proxy for either global winds and eventually repurpose for ocean currents now?
        Need to think about this carefully.
        Need to find a way to put a legitimate 'spin' on the primary axis of the planetoid and model this out
        for the currents
        """

        # create a matplotlib figure and adjust the width and heights
        fig = plt.figure()

        # create a single subplot, just takes over the whole figure if only one is specified
        ax = fig.add_subplot(111, frameon=False, xticks=[], yticks=[])

        # create the boundary
        aoe = unary_union(
            [
                asPolygon(x)
                for x in [item for sublist in cntrs for item in sublist]
                if len(x) > 0
            ]
        ).buffer(-3)

        # add a streamplot
        dy, dx = np.gradient(f)
        c = np.sqrt(dx * dx + dy * dy)
        stream_container = plt.streamplot(
            yy,
            xx,
            dx,
            dy,
            color="c",
            density=density,
            linewidth=1.0 * c / c.max(),
            arrowsize=0.1,
            minlength=min_length,
            maxlength=max_length,
        )

        # this is the data we're extracting from the relief
        widths = np.round(stream_container.lines.get_linewidth(), 1)
        segments = stream_container.lines.get_segments()

        segments_with_width = [
            [segments[i], widths[i]] for i in range(0, len(segments))
        ]

        cleaned = [
            [asLineString(p[0][:, [1, 0]]), p[1]]
            for p in segments_with_width
            if -90 < p[0][0].any() < 90 and -180 < p[0][1].any() < 180
        ]
        stream_container = [p for p in cleaned if p[0].intersects(aoe)]

        plt.close(fig)

        return stream_container

    def _clean_contours(self, cntrs):
        """Use Shapely to modify the contours to prevent the case where Plotly
        fills the inverted section instead."""
        cleaned = list()
        for ix, line in enumerate(cntrs):
            for il, l in enumerate(line):
                # expanding and contracting like this has a smoothing effect
                poly = (
                    asPolygon(l).buffer(0.01, join_style=1).buffer(-0.01, join_style=1)
                )
                if poly.geom_type == "MultiPolygon":
                    polys = [np.array(p.exterior.coords) for p in list(poly)]
                    coords = []
                    for co in coords:
                        if co.shape[0] >= 3:
                            coords.append(co)
                    cleaned.append(coords)

                else:
                    coords = np.array(poly.exterior.coords)
                    if coords.shape[0] >= 3:
                        cleaned.append([coords])
        return cleaned

    def _calculate_hillshade(self, array, azimuth, angle_altitude):
        """Calculate a hillshade over the generated topography."""

        # hacky fix for now - need to trace what's making the mirroring necessary
        azimuth += 180
        if azimuth >= 360:
            azimuth = azimuth - 360

        x, y = np.gradient(array)
        slope = np.pi / 2.0 - np.arctan(np.sqrt(x * x + y * y))
        aspect = np.arctan2(-x, y)
        azimuthrad = azimuth * np.pi / 180.0
        altituderad = angle_altitude * np.pi / 180.0
        shaded = np.sin(altituderad) * np.sin(slope) + np.cos(altituderad) * np.cos(
            slope
        ) * np.cos(azimuthrad - aspect)
        return 255 * (shaded + 1) / 2

    def plot_surface(self):
        """This plots the surface layer which we need because we can't set it
        directly."""
        # globe
        self.fig.add_trace(
            go.Scattergeo(
                lon=[-179.9, 179.9, 179.9, -179.9],
                lat=[89.9, 89.9, -89.9, -89.9],
                mode="lines",
                line=dict(width=1, color=self.ocean_colour),
                fill="toself",
                fillcolor=self.ocean_colour,
                hoverinfo="skip",
                opacity=1,
                showlegend=False,
            ),
            row=2,
            col=1,
        )

    def plot_shadows(self):
        """Plot the hillshade-derived shadows."""
        # globe
        for cluster in tqdm(self.shadows, desc="Plotting Shadows"):
            for ix, shadow in enumerate(cluster):
                if ix % 2 == 0:
                    shadow_array = np.array(shadow)
                    self.fig.add_trace(
                        go.Scattergeo(
                            lon=list(shadow_array[:, 0]),
                            lat=list(shadow_array[:, 1]),
                            hoverinfo="skip",
                            mode="lines",
                            line=dict(width=0, color="black"),
                            fill="toself",
                            fillcolor="black",
                            opacity=0.05 + (ix/len(cluster)*0.1),
                            showlegend=False,
                        ),
                        row=2,
                        col=1,
                    )

    def plot_highlight(self):
        """Plot the hillshade-derived lighting."""
        # globe
        for cluster in tqdm(self.highlight, desc="Plotting highlight"):
            for ix, lighting in enumerate(cluster):
                if ix % 2 == 0:
                    lighting_array = np.array(lighting)
                    self.fig.add_trace(
                        go.Scattergeo(
                            lon=list(lighting_array[:, 0]),
                            lat=list(lighting_array[:, 1]),
                            hoverinfo="skip",
                            mode="lines",
                            line=dict(width=0, color="white"),
                            fill="toself",
                            fillcolor="white",
                            opacity=0.01 + (ix/len(cluster)*0.1),
                            showlegend=False,
                        ),
                        row=2,
                        col=1,
                    )

    def plot_contours(self):
        """Plot the topography."""
        for cluster, cntrs in tqdm(self.contours.items(), desc="Plotting contours"):
            #introduce some randomness in the topography layering
            contours = cntrs.copy()
            dont_shuffle_start = contours[0:5]
            dont_shuffle_end = contours[-2:]
            do_shuffle = contours[5:-2]
            random.shuffle(do_shuffle)
            contours = dont_shuffle_start + do_shuffle + dont_shuffle_end
            
            for ix, line in enumerate(contours):
                if ix > (self.max_contour - 3) / len(contours) + 2:
                    if ix % 2 == 0:
                        for l in line:
                            self.fig.add_trace(
                                go.Scattergeo(
                                    lon=list(l[:, 0]),
                                    lat=list(l[:, 1]),
                                    hoverinfo="skip",
                                    mode="lines",
                                    line=dict(
                                        width=0,  # *np.power(np.exp(ix/max_contour),2),
                                        dash="longdashdot",
                                        color="rgb"
                                        + str(
                                            self.cmap(
                                                ix / self.max_contour, bytes=True
                                            )[0:3]
                                        ),
                                    ),
                                    fill="toself",
                                    fillcolor="rgb"
                                    + str(
                                        self.cmap(ix / self.max_contour, bytes=True)[
                                            0:3
                                        ]
                                    ),
                                    opacity=0.05 + ((ix / self.max_contour) * 0.3),
                                    showlegend=False,
                                ),
                                row=2,
                                col=1,
                            )
                    else:
                        for l in line:
                            self.fig.add_trace(
                                go.Scattergeo(
                                    lon=list(l[:, 0]),
                                    lat=list(l[:, 1]),
                                    hoverinfo="skip",
                                    mode="lines",
                                    line=dict(
                                        width=1,  # *np.power(np.exp(ix/max_contour),2),
                                        dash="longdashdot",
                                        color="rgb"
                                        + str(
                                            self.cmap(
                                                ix / self.max_contour, bytes=True
                                            )[0:3]
                                        ),
                                    ),
                                    opacity=0.1 + ((ix / self.max_contour) * 0.5),
                                    showlegend=False,
                                ),
                                row=2,
                                col=1,
                            )

    def plot_relief(self):
        """Plot the relief."""
        # globe
        for cluster in tqdm(self.relief, desc="Plotting relief"):

            for size in np.unique([x[1] for x in cluster]):

                # need to be smarter about segments that touch

                stream_array = np.array(
                    [stream[0].coords for stream in cluster if stream[1] == size]
                )
                stream_array = np.concatenate(
                    [
                        item
                        for sublist in [
                            [x, np.array([[None, None], [None, None]])]
                            for x in stream_array
                        ]
                        for item in sublist
                    ]
                )

                self.fig.add_trace(
                    go.Scattergeo(
                        connectgaps=False,
                        lon=list(stream_array[:, 0]),
                        lat=list(stream_array[:, 1]),
                        hoverinfo="skip",
                        mode="lines",
                        line=dict(
                            width=2 * size,
                            # dash='dot',
                            color='black'#"rgb"
                            #+ str(
                            #    self.cmap(int(stream_array.shape[0] / 3), bytes=True)[0:3]
                            #),
                        ),
                        opacity=0.1 + 0.15 * (1 / np.cos(size) - 1),
                        showlegend=False,
                    ),
                    row=2,
                    col=1,
                )

    def plot_clustered_points(self):
        """Plot the provided point data."""

        # globe
        self.fig.add_trace(
            go.Scattergeo(
                lon=self.data["Longitude"],
                lat=self.data["Latitude"],
                marker_color=self.data["Cluster"],
                hoverinfo="text",
                hovertext=self.data["Cluster"],
                marker_size=2,
                showlegend=False
                #     marker = dict(
                #         symbol='circle-open',
                #      )
            ),
            row=2,
            col=1,
        )

    def update_geos(self):
        """Update config for maps."""
        # globe
        self.fig.update_geos(
            row=2,
            col=1,
            showland=False,
            showcountries=False,
            showocean=False,
            showcoastlines=False,
            showframe=False,
            showrivers=False,
            showlakes=False,
            showsubunits=False,
            bgcolor="rgba(0,0,0,0)",
            projection=dict(type=self.projection, rotation=dict(lon=0, lat=0, roll=0)),
            lonaxis=dict(showgrid=True, gridcolor="rgb(102, 102, 102)", gridwidth=1),
            lataxis=dict(showgrid=True, gridcolor="rgb(102, 102, 102)", gridwidth=1),
        )

    def add_empty_trace(self):
        """Add invisible scatter trace.

        This trace is added to help the autoresize logic work.
        """

        width = int(1920 / 2)
        height = int(1280 / 2)
        self.fig.add_trace(
            go.Scatter(
                x=[0, width],
                y=[0, height],
                mode="markers",
                marker_opacity=0,
                showlegend=False,
            )
        )

        # Configure axes
        self.fig.update_xaxes(visible=False, fixedrange=True, range=[0, width])

        self.fig.update_yaxes(
            visible=False,
            fixedrange=True,
            range=[0, height],
            # the scaleanchor attribute ensures that the aspect ratio stays constant
            scaleanchor="x",
        )

    def update_layout(self, planet_name="Planetoids"):
        """Update layout config."""

        width = int(1920 / 2)
        height = int(1280 / 2)

        image_array = np.zeros((width, height))
        image_array = self._add_salt_and_pepper(image_array, 0.001).astype("uint8")
        image = Image.fromarray(image_array)

        self.fig.update_layout(
            autosize=True,
            width=width,
            height=height,
            title_text=planet_name,
            showlegend=True,
            dragmode="pan",
            plot_bgcolor="rgba(0,0,0,0)",
            paper_bgcolor="rgba(0,0,0,0)",
            margin=dict(l=2, r=2, t=0, b=0),
            images=[
                dict(
                    source=image,
                    xref="x",
                    yref="y",
                    x=0,
                    y=height,
                    sizex=width,
                    sizey=height,
                    sizing="stretch",
                    opacity=1,
                    layer="below",
                )
            ],
        )
        
    def fit(self, topography_levels=20, lighting_levels=20, relief_density=3):
        """Generate data required for terraforming."""
        # transform 2d components into pseudo lat/longs
        self._rescale_coordinates()
        # generate contours per class
        self.get_all_contours(topography_levels, lighting_levels, relief_density)
        self.data_generated = True

    def terraform(
        self,
        plot_topography=True,
        plot_points=True,
        plot_lighting=True,
        projection = 'orthographic',
        planet_name="Planetoids",
        render=True,
    ):
        """Construct a new world."""
        
        self.projection = projection
        
        if not self.data_generated:
            raise Exception("Please first run .fit() before attemption to terraform.")
        else:
            self.fig = make_subplots(
                rows=3,
                cols=2,
                vertical_spacing=0.05,
                # column_widths=[0.5, 0.5],
                row_heights=[0.05, 0.93, 0.02],
                specs=[
                    [None, None],
                    [{"type": "scattergeo", "colspan": 2}, None],
                    [None, None],
                ],
                subplot_titles=(planet_name, ""),
            )

            self.add_empty_trace()

            # identify the maximum number of contours per continent
            self.max_contour = max([len(contour) for contour in self.contours.values()])
            self.cmap = cm.get_cmap(self.ecology, self.max_contour + 1)

            self.ocean_colour = "rgb" + str(
                self.cmap(1 / self.max_contour, bytes=True)[0:3]
            )

            self.plot_surface()

            if plot_topography:
                self.plot_contours()

            self.plot_relief()

            if plot_lighting:
                self.plot_highlight()
                self.plot_shadows()

            if plot_points:
                self.plot_clustered_points()

            self.update_geos()

            self.update_layout(planet_name)

            if render:
                self.fig.show()

    def fit_terraform(
        self,
        topography_levels=20,
        lighting_levels=20,
        relief_density=3,
        plot_topography=True,
        plot_points=True,
        plot_lighting=True,
        projection='orthographic',
        planet_name="Planetoids",
        render=True,
    ):
        """Fit and terraform in a single step, akin to fit_transform people are
        used to."""
        self.fit(topography_levels=topography_levels, lighting_levels=lighting_levels, relief_density=relief_density)
        self.terraform(plot_topography, plot_points, plot_lighting, projection, planet_name, render)

    def save(self, filename="planetoid.html", output_type='file', include_plotlyjs=True, auto_open=False):
        offline.plot(self.fig, filename = filename, output_type=output_type, include_plotlyjs=include_plotlyjs, auto_open=auto_open)


    def _add_salt_and_pepper(self, gb, prob):
        """Adds "Salt & Pepper" noise to an image.

        gb: should be one-channel image with pixels in [0, 1] range
        prob: probability (threshold) that controls level of noise
        """

        rnd = np.random.rand(gb.shape[0], gb.shape[1])
        noisy = gb.copy()
        noisy[rnd < prob] = 0
        noisy[rnd > 1 - prob] = 255
        return noisy
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#planetoids.Planetoid">Planetoid</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, data, y, x, cluster_field=None, ecology=&#39;gist_earth&#39;, random_state=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.__init__', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.__init__" class="source">
    <pre><code>def __init__(
    self,
    data,
    y,
    x,
    cluster_field=None,
    ecology="gist_earth",
    random_state=None
):
    self.data = None
    self.y = None
    self.x = None
    self.cluster_field = None
    self.ecology = None
    self.random_state=None
    
    self.data_generated = False
    if isinstance(data, pd.DataFrame):
        self.data = data
    else:
        raise ValueError("Please provide a pandas DataFrame")
    if y in self.data.columns:
        self.y = y
    else:
        raise ValueError("X field not in provided DataFrame")
    if x in self.data.columns:
        self.x = x
    else:
        raise ValueError("Y field not in provided DataFrame")
    if cluster_field is not None or cluster_field in self.data.columns:
        self.cluster_field = cluster_field
    else:
        raise ValueError("Cluster field not in provided DataFrame")
    try:
        cm.get_cmap(ecology, 1)
        self.ecology = ecology
    except Exception as e:
        raise ValueError(e)
    if isinstance(random_state, int):
        self.random_state = random_state
        np.random.seed(self.random_state)
        random.seed(self.random_state)
        cv.setRNGSeed(self.random_state)
    elif random_state is None:
        pass
    else:
        raise ValueError("Please provide an integer value for your random seed")
        
    # only keep what we need
    self.data = self.data[[y, x, cluster_field]]
    # set the rest
    self.contours = dict()
    self.ocean_colour = None
    self.fig = None
    self.cmap = None
    self.max_contour = None
    self.shadows = list()
    self.highlight = list()
    self.topos = list()
    self.relief = list()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.add_empty_trace">
    <p>def <span class="ident">add_empty_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Add invisible scatter trace.</p>
<p>This trace is added to help the autoresize logic work.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.add_empty_trace', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.add_empty_trace" class="source">
    <pre><code>def add_empty_trace(self):
    """Add invisible scatter trace.
    This trace is added to help the autoresize logic work.
    """
    width = int(1920 / 2)
    height = int(1280 / 2)
    self.fig.add_trace(
        go.Scatter(
            x=[0, width],
            y=[0, height],
            mode="markers",
            marker_opacity=0,
            showlegend=False,
        )
    )
    # Configure axes
    self.fig.update_xaxes(visible=False, fixedrange=True, range=[0, width])
    self.fig.update_yaxes(
        visible=False,
        fixedrange=True,
        range=[0, height],
        # the scaleanchor attribute ensures that the aspect ratio stays constant
        scaleanchor="x",
    )
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.fit">
    <p>def <span class="ident">fit</span>(</p><p>self, topography_levels=20, lighting_levels=20, relief_density=3)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate data required for terraforming.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.fit', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.fit" class="source">
    <pre><code>def fit(self, topography_levels=20, lighting_levels=20, relief_density=3):
    """Generate data required for terraforming."""
    # transform 2d components into pseudo lat/longs
    self._rescale_coordinates()
    # generate contours per class
    self.get_all_contours(topography_levels, lighting_levels, relief_density)
    self.data_generated = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.fit_terraform">
    <p>def <span class="ident">fit_terraform</span>(</p><p>self, topography_levels=20, lighting_levels=20, relief_density=3, plot_topography=True, plot_points=True, plot_lighting=True, projection=&#39;orthographic&#39;, planet_name=&#39;Planetoids&#39;, render=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Fit and terraform in a single step, akin to fit_transform people are
used to.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.fit_terraform', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.fit_terraform" class="source">
    <pre><code>def fit_terraform(
    self,
    topography_levels=20,
    lighting_levels=20,
    relief_density=3,
    plot_topography=True,
    plot_points=True,
    plot_lighting=True,
    projection='orthographic',
    planet_name="Planetoids",
    render=True,
):
    """Fit and terraform in a single step, akin to fit_transform people are
    used to."""
    self.fit(topography_levels=topography_levels, lighting_levels=lighting_levels, relief_density=relief_density)
    self.terraform(plot_topography, plot_points, plot_lighting, projection, planet_name, render)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.generate_highlight_polygons">
    <p>def <span class="ident">generate_highlight_polygons</span>(</p><p>self, hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.generate_highlight_polygons', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.generate_highlight_polygons" class="source">
    <pre><code>def generate_highlight_polygons(
    self, hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
):
    # self.shadows = list()
    # we have to strech it for the opencv function to catch the edges properly
    hs_array = (
        (hillshade - hillshade.min()) / (hillshade.max() - hillshade.min()) * 255
    )
    hist, bin_edges = np.histogram(hs_array, bins=lighting_levels + 5)
    # bin_centers = 0.5*(bin_edges[:-1] + bin_edges[1:])
    # still need to refine this, but this piece here should help catch only the 'light side' highlights
    bin_edges = [x for x in bin_edges if x <= 70]
    highlight = []
    for b in list(zip(bin_edges[:-1], bin_edges[1:])):
        hs_array_binary_slice = hs_array.copy()
        hs_array_binary_slice[
            (hs_array_binary_slice < b[0]) & (hs_array_binary_slice != 1)
        ] = 0
        hs_array_binary_slice[
            (hs_array_binary_slice >= b[0]) & (hs_array_binary_slice < b[1])
        ] = 1
        # hs_array_binary_slice[(hs_array_binary_slice>=b[1]) & (hs_array_binary_slice != 1)] = 0
        hs_array_binary_slice = np.flipud(hs_array_binary_slice)
        hs_array_binary_slice = hs_array_binary_slice.astype(np.uint8)
        # plt.imshow(hs_array_binary_slice,cmap='Greys', extent=[xmin, xmax, ymin, ymax])
        # plt.show()
        contours, hierarchy = cv.findContours(
            hs_array_binary_slice.copy(), cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE
        )
        for cntr in contours:
            x_loc = [xx[pair[0][0], pair[0][1]] for pair in cntr]
            y_loc = [yy[pair[0][0], pair[0][1]] for pair in cntr]
            # get rid of polygons that touch the bondary of the calculated extent
            if (
                xmin not in x_loc
                and xmax not in x_loc
                and ymin not in y_loc
                and ymax not in y_loc
            ):
                coords = list(zip(x_loc + [x_loc[0]], y_loc + [y_loc[0]]))
                if len(coords) > 3:
                    # attempt some smoothing
                    coords = list(
                        asPolygon(coords)
                        .simplify(0.01)
                        .buffer(3, join_style=1)
                        .buffer(-3, join_style=1)
                        .exterior.coords
                    )
                    highlight.append(coords)
    self.highlight.append(highlight)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.generate_hillshade_polygons">
    <p>def <span class="ident">generate_hillshade_polygons</span>(</p><p>self, hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.generate_hillshade_polygons', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.generate_hillshade_polygons" class="source">
    <pre><code>def generate_hillshade_polygons(
    self, hillshade, xx, yy, xmin, xmax, ymin, ymax, lighting_levels
):
    # self.shadows = list()
    # we have to strech it for the opencv function to catch the edges properly
    hs_array = (
        (hillshade - hillshade.min()) / (hillshade.max() - hillshade.min()) * 255
    )
    hist, bin_edges = np.histogram(hs_array, bins=lighting_levels + 5)
    # bin_centers = 0.5*(bin_edges[:-1] + bin_edges[1:])
    # still need to refine this, but this piece here should help catch only the shadows and not the 'light side'
    bin_edges = [x for x in bin_edges if x > 180]
    cluster_shadows = []
    for b in list(zip(bin_edges[:-1], bin_edges[1:])):
        hs_array_binary_slice = hs_array.copy()
        hs_array_binary_slice[
            (hs_array_binary_slice < b[0]) & (hs_array_binary_slice != 1)
        ] = 0
        hs_array_binary_slice[
            (hs_array_binary_slice >= b[0]) & (hs_array_binary_slice < b[1])
        ] = 1
        # hs_array_binary_slice[(hs_array_binary_slice>=b[1]) & (hs_array_binary_slice != 1)] = 0
        hs_array_binary_slice = np.flipud(hs_array_binary_slice)
        hs_array_binary_slice = hs_array_binary_slice.astype(np.uint8)
        # plt.imshow(hs_array_binary_slice,cmap='Greys', extent=[xmin, xmax, ymin, ymax])
        # plt.show()
        contours, hierarchy = cv.findContours(
            hs_array_binary_slice.copy(), cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE
        )
        for cntr in contours:
            x_loc = [xx[pair[0][0], pair[0][1]] for pair in cntr]
            y_loc = [yy[pair[0][0], pair[0][1]] for pair in cntr]
            # get rid of polygons that touch the bondary of the calculated extent
            if (
                xmin not in x_loc
                and xmax not in x_loc
                and ymin not in y_loc
                and ymax not in y_loc
            ):
                coords = list(zip(x_loc + [x_loc[0]], y_loc + [y_loc[0]]))
                if len(coords) > 3:
                    # attempt some smoothing and reorienting of generated polygons
                    coords = list(
                        asPolygon(coords)
                        .simplify(0.01)
                        .buffer(3, join_style=1)
                        .buffer(-3, join_style=1)
                        .exterior.coords
                    )
                    cluster_shadows.append(coords)
    self.shadows.append(cluster_shadows)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.generate_relief">
    <p>def <span class="ident">generate_relief</span>(</p><p>self, f, xx, yy, cntrs, density=3, min_length=0.005, max_length=0.2)</p>
    </div>
    

    
  
    <div class="desc"><p>Still need to have a proper rationale for this apart from it
potentially looking good.</p>
<p>since this effectively represents the gradient of the topography - is it good enough to use
this as a proxy for either global winds and eventually repurpose for ocean currents now?
Need to think about this carefully.
Need to find a way to put a legitimate 'spin' on the primary axis of the planetoid and model this out
for the currents</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.generate_relief', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.generate_relief" class="source">
    <pre><code>def generate_relief(
    self, f, xx, yy, cntrs, density=3, min_length=0.005, max_length=0.2
):
    """Still need to have a proper rationale for this apart from it
    potentially looking good.
    since this effectively represents the gradient of the topography - is it good enough to use
    this as a proxy for either global winds and eventually repurpose for ocean currents now?
    Need to think about this carefully.
    Need to find a way to put a legitimate 'spin' on the primary axis of the planetoid and model this out
    for the currents
    """
    # create a matplotlib figure and adjust the width and heights
    fig = plt.figure()
    # create a single subplot, just takes over the whole figure if only one is specified
    ax = fig.add_subplot(111, frameon=False, xticks=[], yticks=[])
    # create the boundary
    aoe = unary_union(
        [
            asPolygon(x)
            for x in [item for sublist in cntrs for item in sublist]
            if len(x) > 0
        ]
    ).buffer(-3)
    # add a streamplot
    dy, dx = np.gradient(f)
    c = np.sqrt(dx * dx + dy * dy)
    stream_container = plt.streamplot(
        yy,
        xx,
        dx,
        dy,
        color="c",
        density=density,
        linewidth=1.0 * c / c.max(),
        arrowsize=0.1,
        minlength=min_length,
        maxlength=max_length,
    )
    # this is the data we're extracting from the relief
    widths = np.round(stream_container.lines.get_linewidth(), 1)
    segments = stream_container.lines.get_segments()
    segments_with_width = [
        [segments[i], widths[i]] for i in range(0, len(segments))
    ]
    cleaned = [
        [asLineString(p[0][:, [1, 0]]), p[1]]
        for p in segments_with_width
        if -90 < p[0][0].any() < 90 and -180 < p[0][1].any() < 180
    ]
    stream_container = [p for p in cleaned if p[0].intersects(aoe)]
    plt.close(fig)
    return stream_container
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.get_all_contours">
    <p>def <span class="ident">get_all_contours</span>(</p><p>self, topography_levels=20, lighting_levels=20, relief_density=3)</p>
    </div>
    

    
  
    <div class="desc"><p>Get all of the contours per class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.get_all_contours', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.get_all_contours" class="source">
    <pre><code>def get_all_contours(self, topography_levels=20, lighting_levels=20, relief_density=3):
    """Get all of the contours per class."""
    for cluster in tqdm(
        np.unique(self.data["Cluster"].values), desc="Generating data"
    ):
        points_df = self.data.loc[
            self.data["Cluster"] == cluster, ["Longitude", "Latitude"]
        ]
        self._get_contours(cluster, points_df, topography_levels, lighting_levels, relief_density)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.plot_clustered_points">
    <p>def <span class="ident">plot_clustered_points</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Plot the provided point data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.plot_clustered_points', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.plot_clustered_points" class="source">
    <pre><code>def plot_clustered_points(self):
    """Plot the provided point data."""
    # globe
    self.fig.add_trace(
        go.Scattergeo(
            lon=self.data["Longitude"],
            lat=self.data["Latitude"],
            marker_color=self.data["Cluster"],
            hoverinfo="text",
            hovertext=self.data["Cluster"],
            marker_size=2,
            showlegend=False
            #     marker = dict(
            #         symbol='circle-open',
            #      )
        ),
        row=2,
        col=1,
    )
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.plot_contours">
    <p>def <span class="ident">plot_contours</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Plot the topography.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.plot_contours', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.plot_contours" class="source">
    <pre><code>def plot_contours(self):
    """Plot the topography."""
    for cluster, cntrs in tqdm(self.contours.items(), desc="Plotting contours"):
        #introduce some randomness in the topography layering
        contours = cntrs.copy()
        dont_shuffle_start = contours[0:5]
        dont_shuffle_end = contours[-2:]
        do_shuffle = contours[5:-2]
        random.shuffle(do_shuffle)
        contours = dont_shuffle_start + do_shuffle + dont_shuffle_end
        
        for ix, line in enumerate(contours):
            if ix > (self.max_contour - 3) / len(contours) + 2:
                if ix % 2 == 0:
                    for l in line:
                        self.fig.add_trace(
                            go.Scattergeo(
                                lon=list(l[:, 0]),
                                lat=list(l[:, 1]),
                                hoverinfo="skip",
                                mode="lines",
                                line=dict(
                                    width=0,  # *np.power(np.exp(ix/max_contour),2),
                                    dash="longdashdot",
                                    color="rgb"
                                    + str(
                                        self.cmap(
                                            ix / self.max_contour, bytes=True
                                        )[0:3]
                                    ),
                                ),
                                fill="toself",
                                fillcolor="rgb"
                                + str(
                                    self.cmap(ix / self.max_contour, bytes=True)[
                                        0:3
                                    ]
                                ),
                                opacity=0.05 + ((ix / self.max_contour) * 0.3),
                                showlegend=False,
                            ),
                            row=2,
                            col=1,
                        )
                else:
                    for l in line:
                        self.fig.add_trace(
                            go.Scattergeo(
                                lon=list(l[:, 0]),
                                lat=list(l[:, 1]),
                                hoverinfo="skip",
                                mode="lines",
                                line=dict(
                                    width=1,  # *np.power(np.exp(ix/max_contour),2),
                                    dash="longdashdot",
                                    color="rgb"
                                    + str(
                                        self.cmap(
                                            ix / self.max_contour, bytes=True
                                        )[0:3]
                                    ),
                                ),
                                opacity=0.1 + ((ix / self.max_contour) * 0.5),
                                showlegend=False,
                            ),
                            row=2,
                            col=1,
                        )
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.plot_highlight">
    <p>def <span class="ident">plot_highlight</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Plot the hillshade-derived lighting.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.plot_highlight', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.plot_highlight" class="source">
    <pre><code>def plot_highlight(self):
    """Plot the hillshade-derived lighting."""
    # globe
    for cluster in tqdm(self.highlight, desc="Plotting highlight"):
        for ix, lighting in enumerate(cluster):
            if ix % 2 == 0:
                lighting_array = np.array(lighting)
                self.fig.add_trace(
                    go.Scattergeo(
                        lon=list(lighting_array[:, 0]),
                        lat=list(lighting_array[:, 1]),
                        hoverinfo="skip",
                        mode="lines",
                        line=dict(width=0, color="white"),
                        fill="toself",
                        fillcolor="white",
                        opacity=0.01 + (ix/len(cluster)*0.1),
                        showlegend=False,
                    ),
                    row=2,
                    col=1,
                )
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.plot_relief">
    <p>def <span class="ident">plot_relief</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Plot the relief.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.plot_relief', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.plot_relief" class="source">
    <pre><code>def plot_relief(self):
    """Plot the relief."""
    # globe
    for cluster in tqdm(self.relief, desc="Plotting relief"):
        for size in np.unique([x[1] for x in cluster]):
            # need to be smarter about segments that touch
            stream_array = np.array(
                [stream[0].coords for stream in cluster if stream[1] == size]
            )
            stream_array = np.concatenate(
                [
                    item
                    for sublist in [
                        [x, np.array([[None, None], [None, None]])]
                        for x in stream_array
                    ]
                    for item in sublist
                ]
            )
            self.fig.add_trace(
                go.Scattergeo(
                    connectgaps=False,
                    lon=list(stream_array[:, 0]),
                    lat=list(stream_array[:, 1]),
                    hoverinfo="skip",
                    mode="lines",
                    line=dict(
                        width=2 * size,
                        # dash='dot',
                        color='black'#"rgb"
                        #+ str(
                        #    self.cmap(int(stream_array.shape[0] / 3), bytes=True)[0:3]
                        #),
                    ),
                    opacity=0.1 + 0.15 * (1 / np.cos(size) - 1),
                    showlegend=False,
                ),
                row=2,
                col=1,
            )
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.plot_shadows">
    <p>def <span class="ident">plot_shadows</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Plot the hillshade-derived shadows.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.plot_shadows', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.plot_shadows" class="source">
    <pre><code>def plot_shadows(self):
    """Plot the hillshade-derived shadows."""
    # globe
    for cluster in tqdm(self.shadows, desc="Plotting Shadows"):
        for ix, shadow in enumerate(cluster):
            if ix % 2 == 0:
                shadow_array = np.array(shadow)
                self.fig.add_trace(
                    go.Scattergeo(
                        lon=list(shadow_array[:, 0]),
                        lat=list(shadow_array[:, 1]),
                        hoverinfo="skip",
                        mode="lines",
                        line=dict(width=0, color="black"),
                        fill="toself",
                        fillcolor="black",
                        opacity=0.05 + (ix/len(cluster)*0.1),
                        showlegend=False,
                    ),
                    row=2,
                    col=1,
                )
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.plot_surface">
    <p>def <span class="ident">plot_surface</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This plots the surface layer which we need because we can't set it
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.plot_surface', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.plot_surface" class="source">
    <pre><code>def plot_surface(self):
    """This plots the surface layer which we need because we can't set it
    directly."""
    # globe
    self.fig.add_trace(
        go.Scattergeo(
            lon=[-179.9, 179.9, 179.9, -179.9],
            lat=[89.9, 89.9, -89.9, -89.9],
            mode="lines",
            line=dict(width=1, color=self.ocean_colour),
            fill="toself",
            fillcolor=self.ocean_colour,
            hoverinfo="skip",
            opacity=1,
            showlegend=False,
        ),
        row=2,
        col=1,
    )
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=&#39;planetoid.html&#39;, output_type=&#39;file&#39;, include_plotlyjs=True, auto_open=False)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.save', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.save" class="source">
    <pre><code>def save(self, filename="planetoid.html", output_type='file', include_plotlyjs=True, auto_open=False):
    offline.plot(self.fig, filename = filename, output_type=output_type, include_plotlyjs=include_plotlyjs, auto_open=auto_open)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.terraform">
    <p>def <span class="ident">terraform</span>(</p><p>self, plot_topography=True, plot_points=True, plot_lighting=True, projection=&#39;orthographic&#39;, planet_name=&#39;Planetoids&#39;, render=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Construct a new world.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.terraform', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.terraform" class="source">
    <pre><code>def terraform(
    self,
    plot_topography=True,
    plot_points=True,
    plot_lighting=True,
    projection = 'orthographic',
    planet_name="Planetoids",
    render=True,
):
    """Construct a new world."""
    
    self.projection = projection
    
    if not self.data_generated:
        raise Exception("Please first run .fit() before attemption to terraform.")
    else:
        self.fig = make_subplots(
            rows=3,
            cols=2,
            vertical_spacing=0.05,
            # column_widths=[0.5, 0.5],
            row_heights=[0.05, 0.93, 0.02],
            specs=[
                [None, None],
                [{"type": "scattergeo", "colspan": 2}, None],
                [None, None],
            ],
            subplot_titles=(planet_name, ""),
        )
        self.add_empty_trace()
        # identify the maximum number of contours per continent
        self.max_contour = max([len(contour) for contour in self.contours.values()])
        self.cmap = cm.get_cmap(self.ecology, self.max_contour + 1)
        self.ocean_colour = "rgb" + str(
            self.cmap(1 / self.max_contour, bytes=True)[0:3]
        )
        self.plot_surface()
        if plot_topography:
            self.plot_contours()
        self.plot_relief()
        if plot_lighting:
            self.plot_highlight()
            self.plot_shadows()
        if plot_points:
            self.plot_clustered_points()
        self.update_geos()
        self.update_layout(planet_name)
        if render:
            self.fig.show()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.update_geos">
    <p>def <span class="ident">update_geos</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Update config for maps.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.update_geos', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.update_geos" class="source">
    <pre><code>def update_geos(self):
    """Update config for maps."""
    # globe
    self.fig.update_geos(
        row=2,
        col=1,
        showland=False,
        showcountries=False,
        showocean=False,
        showcoastlines=False,
        showframe=False,
        showrivers=False,
        showlakes=False,
        showsubunits=False,
        bgcolor="rgba(0,0,0,0)",
        projection=dict(type=self.projection, rotation=dict(lon=0, lat=0, roll=0)),
        lonaxis=dict(showgrid=True, gridcolor="rgb(102, 102, 102)", gridwidth=1),
        lataxis=dict(showgrid=True, gridcolor="rgb(102, 102, 102)", gridwidth=1),
    )
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="planetoids.Planetoid.update_layout">
    <p>def <span class="ident">update_layout</span>(</p><p>self, planet_name=&#39;Planetoids&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Update layout config.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-planetoids.Planetoid.update_layout', this);">Show source &equiv;</a></p>
  <div id="source-planetoids.Planetoid.update_layout" class="source">
    <pre><code>def update_layout(self, planet_name="Planetoids"):
    """Update layout config."""
    width = int(1920 / 2)
    height = int(1280 / 2)
    image_array = np.zeros((width, height))
    image_array = self._add_salt_and_pepper(image_array, 0.001).astype("uint8")
    image = Image.fromarray(image_array)
    self.fig.update_layout(
        autosize=True,
        width=width,
        height=height,
        title_text=planet_name,
        showlegend=True,
        dragmode="pan",
        plot_bgcolor="rgba(0,0,0,0)",
        paper_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=2, r=2, t=0, b=0),
        images=[
            dict(
                source=image,
                xref="x",
                yref="y",
                x=0,
                y=height,
                sizex=width,
                sizey=height,
                sizing="stretch",
                opacity=1,
                layer="below",
            )
        ],
    )
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="planetoids.Planetoid.cluster_field" class="name">var <span class="ident">cluster_field</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.cmap" class="name">var <span class="ident">cmap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.contours" class="name">var <span class="ident">contours</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.data" class="name">var <span class="ident">data</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.data_generated" class="name">var <span class="ident">data_generated</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.ecology" class="name">var <span class="ident">ecology</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.fig" class="name">var <span class="ident">fig</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.highlight" class="name">var <span class="ident">highlight</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.max_contour" class="name">var <span class="ident">max_contour</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.ocean_colour" class="name">var <span class="ident">ocean_colour</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.random_state" class="name">var <span class="ident">random_state</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.relief" class="name">var <span class="ident">relief</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.shadows" class="name">var <span class="ident">shadows</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.topos" class="name">var <span class="ident">topos</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.x" class="name">var <span class="ident">x</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="planetoids.Planetoid.y" class="name">var <span class="ident">y</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
